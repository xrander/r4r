# Data Types in R {#sec-data-types}

::: {.callout-caution appearance="minimal"}
This section is still under development
:::

Researchers regardless of the field are analysts working with various forms of data, which can be in form of survey responses, secondary data, field or lab measurements. These data are usually a combination of numbers in the form of a measurements, words or text, such as survey participants responses, or a ranking or category such as yes/no responses, income level or marital status. Before proceeding with any analysis, it is crucial to understand the types of data we are working with. In the research process, as seen in @fig-str, data collection and analysis are key stages.

Each data has its own unique structure and requirements influencing the method used in analyzing them. Understanding the distinctions between different data types ensures you can manipulate, analyze and interpret the findings from your data effectively. Here, we will explore the data types in R

![Stages of Research](images/research-stages.png){#fig-str fig-align="center"}

There are more than seven different data types in R, five which will be used frequently in this book. In R,  the function `typeof()` and `class()` are used to check the data type of a variable. The data types are in R are:

-   character
-   factor
-   double
-   integer
-   complex
-   logical
-   date
-   POSIXt

## Character

Characters represent text and are written in R by enclosing contents in quotation marks. The quotation mark can either be the single `'` or double `"` and anything can be the content of a string as long as the quotation mark enclose the content. It is more common to use the double `"` than the single `'`. 

```{r}
"tree"
```

We can check the data type of the text *"tree"* with either `class()` or `typeof()`.

```{r}
typeof("tree")
class("tree")
class("2")
class("+")
```

When we assign characters to a variable, the content of the variable will be evaluated and not the variable in its self. As explained in @sec-assign variables are references and not a value in themselves.

```{r}
tree <- "Quercus robur"
class(name_of_tree)
```

Let's look at the example below, we have error because `oak` is an object with no values assigned to it. So `oak` and "oak" are different. The latter is a character while the former is an object.

```{r}
#| error: true

class(oak)
```

There is a way to check if an objects is a character or not different from using `class()` and `typeof()`. Using `is.character()` function returns a TRUE or FALSE when checking if objects are character data type.

```{r}
is.character("moabi")
is.character(2)
is.character("2")
```

## Factors

Factors are used to represent categorical data in R. In R, factors are always leveled, and can only contain predefined values. They can either be ordered (ordinal) or unordered (nominal). The function `factor()` is used to create factors in R.

### Nominal Factor

These are unordered categorical data with levels. There's no degree of distance or ranking in nominal factor variables. Example can be a finite number of tree species in an experimental setup, different types of fertilizers for crops, types of poultry birds

```{r}
#| label: nominal-factor
tree_names <- factor(c("Lophira alata", "Triplochiton scleroxylon", "Mansonia altissima",
                       "Celtis africana", "Borassus aethiopum"))
poultry_birds <-factor(c("breeders", "broilers", "layers"))
fertilizer <- factor(c("N", "P", "K"))

tree_names
poultry_birds
fertilizer
```

::: {.callout-tip appearance="simple"}
The function `c()` used above is used to combine values.
:::

When we print this variables, notice `Levels` as part of the print with the categories arranged in alphabetical order.
```{r}
class(tree_names)
```
If we use the `typeof()` function on these objects, the result is `integer` which will be discussed in @sec-integer. The result is so because factors are built on top of integers.

```{r}
typeof(tree_names)
```

###   Ordinal Factors
Ordinal factors are somewhat different from nominal or regular factors. When the nominal factors above where created, we did it without specifying a level argument, when the level is specified, we are indicating a rank or degree of distance between the factors. For example let's construct a hypothetical survey response on the satisfaction_level of having trees cut down for other needs other than conservation:


```{r}
#| label: ordered-factor

satisfaction_level <- factor(c("very satisfied", "satisfied", "satisfied",
                               "dissatisfied", "very satisfied", "very dissatisfied",
                               "very satisfied", "dissatisfied"), 
                             levels = c("very dissatisfied", "dissatisfied",
                                        "neutral", "satisfied", "very satisfied")
                )
satisfaction_level
```

On printing the variable we can see that:

*   The levels are not arranged according to alphabetical order, 
*   The order arrangement of the levels when we print the follows the order specified in the argument `levels`,
* The value neutral indicated in levels but not in the data collected is still printed as part of the levels. This indicate that factors are indeed predefined even if data on a particular factor is not collected. 

We can perform a quick check on the frequency of each category using the function `table()`.

```{r}
table(satisfaction_level)
```
 
The result shows `neutral` as having zero, meaning that no respondent choose neutral in this hypothetical survey.

:::{.callout-note appearance="simple"}
we have been using functions a lot now without properly defining what functions are. Just keep in mind that functions are little programs or block of codes that perform specified actions. More will be discussion on that in @sec-fns.
:::


## Integers {#sec-integer}
## Numerical Data

There are two types of numerical data in R, integers and doubles.

-   **Doubles**: These are decimal numbers

```{r}
typeof(1.5)
```

-   **Integers**: These are whole number. They usually having a capital L in front but are printed normally

```{r}
typeof(1L)
```

You can create a sequence of data using **:**. For example to create a sequence of 1 to 15

```{r}
1:15
```

## Logical {#sec-logical}

Boolean also referred to as logical values. Boolean includes `TRUE`, `FALSE` and `NA` which refers to not available.

```{r}
class(TRUE)
class(NA)
class(FALSE)
```

## Objects

R allows you to save data by storing it into objects/variables. Objects are just names we can use to call up stored data. for example:

```{r}
fruits <- factor(c("mango", "papaya", "apple"))
age <- 20
result <- factor(c(0, 1, 3, 4, 5), labels = c("F", "D", "C", "B", "A"),
                ordered = TRUE)
```

The object here is `fruits`, we can get the stored object anytime by calling the object

```{r}
fruits
age
grade
```

## Changing Data Types

Changing data types in R is referred to as coercing the data. The `as._data_type` helps us change between data types.

```{r}
#| label: changing-data-types

tree_names <- c("terminalia", "eucalyptus", "iroko", "oak")
class(tree_names)
```

To change the above to a factor type we'll use the as.factor() function to coerce it into factor data type.

```{r}
tree_names <- as.factor(tree_names)

class(tree_names)
```

We can change this back to factor by using the as.character() function to coerce our data into character data type.

```{r}
tree_names <- as.character(tree_names)
class(tree_names)
```

The as.character() can be used to coerce any data type to character:

```{r}
numbers <- 1:20
class(numbers)
```

```{r}
numbers <- as.character(numbers)
class(numbers)
```

Characters can be changed back to numeric or double data type using the as.double(), as.integer() or as.numeric() function. The functions will return numbers only if what is been coerced contains numbers, else they are returned as NA's

```{r}
tree_height <- c(10, 15, 20, "25m")
class(tree_height)
```

```{r}
tree_height <- as.double(tree_height)
tree_height
class(tree_height)
```

Data types can be converted to different types using the `as.*` including changing to a Boolean data type using the as.logical() function. Inspection after coercion is necessary to ensure that the result is as expected.

```{r}
as.logical(c("TRUE", 1, 0, "FALSE", "F", "T", 3, 4))
```

```{r}
as.logical(c(1, 0, 1, 1, 0, 0 , 1))
```

::: callout-note
Data coercion can either be implicit or explicit. Coercion is explicit when you intentionally change the variable type. Implicit coercion is when R changes the variable type for you automatically depending on when an operation needs it.
:::

## Recommended Reading
  [Chapter 3 of Advanced R by Hadley Wickham, 2019](https://adv-r.hadley.nz/vectors-chap.html) gives in-depth understanding of the data types in R.

  [Hands-On Programming with R by Garret Grolemund](https://rstudio-education.github.io/hopr/r-objects.html) explain the concepts of R in a game-like approach using deck of cards.

## Summary

You learned about the data types in R. They include character, factor, double, integer, and logical. You also learned how to access the properties and how to change from one data type to the other. In the next chapter you will learn about functions in R. You will learn some functions and how to create functions.
